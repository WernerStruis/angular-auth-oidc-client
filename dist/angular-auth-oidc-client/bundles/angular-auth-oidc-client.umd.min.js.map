{"version":3,"sources":["ng://angular-auth-oidc-client/lib/models/jwtkeys.ts","ng://angular-auth-oidc-client/lib/models/authorization-result.ts","ng://angular-auth-oidc-client/lib/models/authorization-state.enum.ts","ng://angular-auth-oidc-client/lib/models/validation-result.enum.ts","ng://angular-auth-oidc-client/lib/models/validate-state-result.model.ts","ng://angular-auth-oidc-client/lib/data-services/oidc-data.service.ts","node_modules/tslib/tslib.es6.js","ng://angular-auth-oidc-client/lib/services/platform.provider.ts","ng://angular-auth-oidc-client/lib/services/auth-configuration.provider.ts","ng://angular-auth-oidc-client/lib/services/oidc.logger.service.ts","ng://angular-auth-oidc-client/lib/services/existing-iframe.service.ts","ng://angular-auth-oidc-client/lib/services/oidc-equality-helper.service.ts","ng://angular-auth-oidc-client/lib/services/oidc-token-helper.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.storage.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.common.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.validation.ts","ng://angular-auth-oidc-client/lib/services/oidc-security-state-validation.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.check-session.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.config.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.silent-renew.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.user-service.ts","ng://angular-auth-oidc-client/lib/services/uri-encoder.ts","ng://angular-auth-oidc-client/lib/services/url-parser.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.service.ts","ng://angular-auth-oidc-client/lib/modules/auth.module.ts"],"names":["JwtKeys","this","keys","kty","use","kid","x5t","e","n","x5c","AuthorizationResult","authorizationState","validationResult","isRenewProcess","authorized","forbidden","unauthorized","NotSet","StatesDoNotMatch","SignatureFailed","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","TokenExpired","IncorrectAtHash","Ok","LoginRequired","SecureTokenServerError","ValidateStateResult","access_token","id_token","authResponseIsValid","decoded_id_token","state","ValidationResult","OidcDataService","prototype","getWellknownEndpoints","url","headers","HttpHeaders","set","httpClient","get","getIdentityUserData","token","decodeURIComponent","Injectable","HttpClient","__assign","Object","assign","t","s","i","arguments","length","p","hasOwnProperty","call","apply","__values","o","m","Symbol","iterator","next","value","done","__read","r","ar","push","error","PlatformProvider","defineProperty","isPlatformBrowser","platformId","args","providedIn","decorators","type","Inject","PLATFORM_ID","ConfigurationProvider","mergedOpenIdConfiguration","authWellKnownEndpoints","onConfigurationChangeInternal","asObservable","setup","passedOpenIfConfiguration","passedAuthWellKnownEndpoints","setSpecialCases","currentConfig","platformProvider","isBrowser","start_checksession","silent_renew","use_refresh_token","DEFAULT_CONFIG","stsServer","redirect_url","client_id","response_type","scope","hd_param","post_logout_redirect_uri","silent_renew_url","silent_renew_offset_in_seconds","ignore_nonce_after_refresh","post_login_route","forbidden_route","unauthorized_route","auto_userinfo","auto_clean_state_after_authentication","trigger_authorization_result_event","log_console_warning_active","log_console_debug_active","iss_validation_off","history_cleanup_off","max_id_token_iat_offset_allowed_in_seconds","isauthorizedrace_timeout_in_seconds","disable_iat_offset_validation","storage","Storage","sessionStorage","INITIAL_AUTHWELLKNOWN","issuer","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspection_endpoint","Subject","LoggerService","logError","message","_i","console","__spread","concat","logWarning","configurationProvider","openIDConfiguration","warn","logDebug","log","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","window","document","createElement","id","loggerService","style","display","body","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","EqualityHelperService","areEqual","value1","value2","bothValuesAreArrays","arraysEqual","bothValuesAreStrings","bothValuesAreObjects","JSON","stringify","toLowerCase","oneValueIsStringAndTheOtherIsArray","Array","isArray","valueIsString","valueIsObject","String","arr1","arr2","TokenHelperService","getTokenExpirationDate","dataIdToken","Date","date","setUTCSeconds","exp","getHeaderFromToken","encoded","tokenIsValid","getPartOfToken","getPayloadFromToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","parse","str","output","replace","Error","decoded","atob","Buffer","toString","split","map","c","charCodeAt","slice","join","err","includes","PARTS_OF_TOKEN","OidcSecurityStorage","BrowserStorage","read","key","hasStorage","configProvider","getItem","write","undefined","setItem","OidcSecurityCommon","retrieve","storage_auth_result","store","storage_access_token","storage_id_token","storage_is_authorized","storage_user_data","storage_auth_nonce","storage_code_verifier","storage_auth_state_control","storage_session_state","storage_silent_renew_running","storage_custom_request_params","oidcSecurityStorage","resetStorageData","getAccessToken","getIdToken","getRefreshToken","authResult","refresh_token","OidcSecurityValidation","isTokenExpired","offsetSeconds","tokenHelperService","validate_id_token_exp_not_expired","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","tokenNotExpired","validate_required_id_token","validated","validate_id_token_iat_max_offset","max_offset_allowed_in_seconds","dateTime_iat_id_token","iat","validate_id_token_nonce","local_nonce","nonce","RefreshTokenNoncePlaceholder","validate_id_token_iss","authWellKnownEndpoints_issuer","iss","validate_id_token_aud","aud","arrayHelperService","validateStateFromHashCallback","local_state","validate_userdata_sub_id_token","id_token_sub","userdata_sub","validate_signature_id_token","jwtkeys","header_data","constructor","alg","isValid","_h","tslib_1.__values","_j","publickey","KEYUTIL","getKey","KJUR","jws","JWS","verify","amountOfMatchingKeys","_d","_e","_f","_g","config_validate_response_type","validate_id_token_at_hash","at_hash","isCodeFlow","testdata","generate_at_hash","testValue","hash","crypto","Util","hashString","first128bits","substr","hextob64u","generate_code_verifier","code_challenge","StateValidationService","validateState","jwtKeys","toReturn","oidcSecurityValidation","oidcSecurityCommon","authStateControl","handleUnsuccessfulValidation","authNonce","wellKnownEndpoints","handleSuccessfulValidation","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","OidcSecurityCheckSession","_onCheckSessionChanged","doesSessionExist","existingIFrame","iFrameService","init","_this","lastIFrameRefresh","iframeRefreshInterval","now","from","iframeMessageEvent","messageHandler","bind","addEventListener","contentWindow","location","Observable","create","observer","onload","complete","startCheckingSession","clientId","scheduledHeartBeat","pollServerSession","stopCheckingSession","clearScheduledHeartBeat","_pollServerSessionRecur","pipe","take","subscribe","session_state","sessionState","outstandingMessages","postMessage","setTimeout","heartBeatInterval","zone","runOutsideAngular","clearTimeout","origin","source","data","NgZone","OidcConfigService","configurationLoadedInternal","load","configUrl","switchMap","clientConfiguration","loadUsingConfiguration","catchError","of","toPromise","load_using_stsServer","load_using_custom_stsServer","authWellknownEndpoints","customConfig","clientConfig","ReplaySubject","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","OidcSecuritySilentRenew","initRenew","startRenew","onLoadHandler","removeEventListener","src","OidcSecurityUserService","initUserData","userData","getUserData","setUserData","oidcDataService","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","UrlParserService","getUrlParameter","urlToCheck","name","results","RegExp","exec","OidcSecurityService","_onModuleSetup","_onAuthorizationResult","onConfigurationChange","setupModule","openIdConfiguration","oidcSecurityCheckSession","onCheckSessionChanged","checkSessionChanged","isAuthorized","idToken","accessToken","setIsAuthorized","runTokenValidation","oidcSecuritySilentRenew","boundSilentRenewEvent","silentRenewEventHandler","instanceId_1","Math","random","boundSilentRenewInitEvent_1","detail","dispatchEvent","CustomEvent","_userData","getIsModuleSetup","_isModuleSetup","getIsAuthorized","_isSetupAndAuthorized","getToken","_isAuthorized","getValue","getPayloadFromIdToken","encode","setState","getState","setCustomRequestParameters","params","customRequestParams","authorize","urlHandler","authWellKnownEndpointsLoaded","resetAuthorizationData","code_verifier","createAuthorizeUrl","redirectTo","authorizedCallbackWithCode","authorizedCallbackWithCode$","code","urlParserService","requestTokensWithCode$","requestTokensWithCode","filter","isModuleSetup","requestTokensWithCodeProcedure$","refreshTokensWithCodeProcedure","tokenRequestUrl","post","response","obj","authorizedCodeFlowCallbackProcedure","requestTokensWithCodeProcedure","throwError","silentRenewRunning","authorizedCallbackProcedure","authorizedImplicitFlowCallbackProcedure","reduce","resultData","item","parts","shift","authorizedImplicitFlowCallback","href","history","replaceState","title","pathname","AuthorizationState","router","navigate","getSigningKeys","getValidatedStateResult","setAuthorizationData","getUserinfo","oidcSecurityUserService","sub","logoff","id_token_hint","createEndSessionUrl","refreshSession","handleError","status","silentRenew_1","startCheckingSilentRenew","stopCheckingSilentRenew","_scheduledHeartBeat","runTokenValidationRunning","getEndSessionUrl","stateValidationService","prompt","urlParts","authorizationUrl","HttpParams","fromString","encoder","append","customParams","forEach","authorizationEndsessionUrl","handleErrorGetSigningKeys","errMsg","Response","json","statusText","silentRenewHeartBeatCheck","Router","moduleSetup","BehaviorSubject","onModuleSetup","race$","tap","race","timer","switchMapTo","shareReplay","isSetupAndAuthorized","AuthModule","forRoot","ngModule","providers","provide","useClass","NgModule"],"mappings":"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","sourcesContent":["export class JwtKeys {\r\n    keys: JwtKey[] = [];\r\n}\r\n\r\nexport class JwtKey {\r\n    kty = '';\r\n    use = '';\r\n    kid = '';\r\n    x5t = '';\r\n    e = '';\r\n    n = '';\r\n    x5c: any[] = [];\r\n}\r\n","import { AuthorizationState } from './authorization-state.enum';\r\nimport { ValidationResult } from './validation-result.enum';\r\n\r\nexport class AuthorizationResult {\r\n    constructor(\r\n        public authorizationState: AuthorizationState,\r\n        public validationResult: ValidationResult,\r\n        public isRenewProcess: boolean = false\r\n    ) {}\r\n}\r\n","export enum AuthorizationState {\r\n    authorized = 'authorized',\r\n    forbidden = 'forbidden',\r\n    unauthorized = 'unauthorized'\r\n}\r\n","export enum ValidationResult {\r\n    NotSet = 'NotSet',\r\n    StatesDoNotMatch = 'StatesDoNotMatch',\r\n    SignatureFailed = 'SignatureFailed',\r\n    IncorrectNonce = 'IncorrectNonce',\r\n    RequiredPropertyMissing = 'RequiredPropertyMissing',\r\n    MaxOffsetExpired = 'MaxOffsetExpired',\r\n    IssDoesNotMatchIssuer = 'IssDoesNotMatchIssuer',\r\n    NoAuthWellKnownEndPoints = 'NoAuthWellKnownEndPoints',\r\n    IncorrectAud = 'IncorrectAud',\r\n    TokenExpired = 'TokenExpired',\r\n    IncorrectAtHash = 'IncorrectAtHash',\r\n    Ok = 'Ok',\r\n    LoginRequired = 'LoginRequired',\r\n    SecureTokenServerError = 'SecureTokenServerError'\r\n}\r\n","import { ValidationResult } from './validation-result.enum';\r\n\r\nexport class ValidateStateResult {\r\n    constructor(\r\n        public access_token = '',\r\n        public id_token = '',\r\n        public authResponseIsValid = false,\r\n        public decoded_id_token: any = {},\r\n        public state: ValidationResult = ValidationResult.NotSet\r\n    ) {}\r\n}\r\n","import { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\n@Injectable()\r\nexport class OidcDataService {\r\n    constructor(private httpClient: HttpClient) {}\r\n\r\n    getWellknownEndpoints<T>(url: string): Observable<T> {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n\r\n        return this.httpClient.get<T>(url, {\r\n            headers: headers,\r\n        });\r\n    }\r\n\r\n    getIdentityUserData<T>(url: string, token: string): Observable<T> {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n\r\n        return this.httpClient.get<T>(url, {\r\n            headers: headers,\r\n        });\r\n    }\r\n\r\n    get<T>(url: string): Observable<T> {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n\r\n        return this.httpClient.get<T>(url, {\r\n            headers: headers,\r\n        });\r\n    }\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { isPlatformBrowser } from '@angular/common';\r\nimport { Inject, Injectable, PLATFORM_ID } from '@angular/core';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class PlatformProvider {\r\n    get isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n\r\n    constructor(@Inject(PLATFORM_ID) private platformId: Object) {}\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Subject } from 'rxjs';\r\nimport { OpenIdConfiguration, OpenIdInternalConfiguration } from '../models/auth.configuration';\r\nimport { AuthWellKnownEndpoints } from '../models/auth.well-known-endpoints';\r\nimport { PlatformProvider } from './platform.provider';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class ConfigurationProvider {\r\n    private DEFAULT_CONFIG: OpenIdInternalConfiguration = {\r\n        stsServer: 'https://please_set',\r\n        redirect_url: 'https://please_set',\r\n        client_id: 'please_set',\r\n        response_type: 'code',\r\n        scope: 'openid email profile',\r\n        hd_param: '',\r\n        post_logout_redirect_uri: 'https://please_set',\r\n        start_checksession: false,\r\n        silent_renew: false,\r\n        silent_renew_url: 'https://please_set',\r\n        silent_renew_offset_in_seconds: 0,\r\n        use_refresh_token: false,\r\n        ignore_nonce_after_refresh: false,\r\n        post_login_route: '/',\r\n        forbidden_route: '/forbidden',\r\n        unauthorized_route: '/unauthorized',\r\n        auto_userinfo: true,\r\n        auto_clean_state_after_authentication: true,\r\n        trigger_authorization_result_event: false,\r\n        log_console_warning_active: true,\r\n        log_console_debug_active: false,\r\n        iss_validation_off: false,\r\n        history_cleanup_off: false,\r\n        max_id_token_iat_offset_allowed_in_seconds: 3,\r\n        isauthorizedrace_timeout_in_seconds: 5,\r\n        disable_iat_offset_validation: false,\r\n        storage: typeof Storage !== 'undefined' ? sessionStorage : null,\r\n    };\r\n\r\n    private INITIAL_AUTHWELLKNOWN: AuthWellKnownEndpoints = {\r\n        issuer: '',\r\n        jwks_uri: '',\r\n        authorization_endpoint: '',\r\n        token_endpoint: '',\r\n        userinfo_endpoint: '',\r\n        end_session_endpoint: '',\r\n        check_session_iframe: '',\r\n        revocation_endpoint: '',\r\n        introspection_endpoint: '',\r\n    };\r\n\r\n    private mergedOpenIdConfiguration: OpenIdInternalConfiguration = this.DEFAULT_CONFIG;\r\n    private authWellKnownEndpoints: AuthWellKnownEndpoints = this.INITIAL_AUTHWELLKNOWN;\r\n\r\n    private onConfigurationChangeInternal = new Subject<OpenIdConfiguration>();\r\n\r\n    get openIDConfiguration(): OpenIdInternalConfiguration {\r\n        return this.mergedOpenIdConfiguration;\r\n    }\r\n\r\n    get wellKnownEndpoints(): AuthWellKnownEndpoints {\r\n        return this.authWellKnownEndpoints;\r\n    }\r\n\r\n    get onConfigurationChange() {\r\n        return this.onConfigurationChangeInternal.asObservable();\r\n    }\r\n\r\n    constructor(private platformProvider: PlatformProvider) {}\r\n\r\n    setup(\r\n        passedOpenIfConfiguration: OpenIdConfiguration | null | undefined,\r\n        passedAuthWellKnownEndpoints: AuthWellKnownEndpoints | null | undefined\r\n    ) {\r\n        this.mergedOpenIdConfiguration = { ...this.mergedOpenIdConfiguration, ...passedOpenIfConfiguration };\r\n        this.setSpecialCases(this.mergedOpenIdConfiguration);\r\n        this.authWellKnownEndpoints = { ...passedAuthWellKnownEndpoints };\r\n        this.onConfigurationChangeInternal.next({ ...this.mergedOpenIdConfiguration });\r\n    }\r\n\r\n    private setSpecialCases(currentConfig: OpenIdConfiguration) {\r\n        if (!this.platformProvider.isBrowser) {\r\n            currentConfig.start_checksession = false;\r\n            currentConfig.silent_renew = false;\r\n            currentConfig.use_refresh_token = false;\r\n        }\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\n\r\n@Injectable()\r\nexport class LoggerService {\r\n    constructor(private configurationProvider: ConfigurationProvider) {}\r\n\r\n    logError(message: any, ...args: any[]) {\r\n        console.error(message, ...args);\r\n    }\r\n\r\n    logWarning(message: any) {\r\n        if (this.configurationProvider.openIDConfiguration.log_console_warning_active) {\r\n            console.warn(message);\r\n        }\r\n    }\r\n\r\n    logDebug(message: any) {\r\n        if (this.configurationProvider.openIDConfiguration.log_console_debug_active) {\r\n            console.log(message);\r\n        }\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { LoggerService } from './oidc.logger.service';\r\n\r\n@Injectable()\r\nexport class IFrameService {\r\n    constructor(private loggerService: LoggerService) {}\r\n\r\n    getExistingIFrame(identifier: string): HTMLIFrameElement | null {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    addIFrameToWindowBody(identifier: string): HTMLIFrameElement {\r\n        const sessionIframe = window.document.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        this.loggerService.logDebug(sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        window.document.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n\r\n    private getIFrameFromParentWindow(identifier: string): HTMLIFrameElement | null {\r\n        try {\r\n            const iFrameElement = window.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private getIFrameFromWindow(identifier: string): HTMLIFrameElement | null {\r\n        const iFrameElement = window.document.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private isIFrameElement(element: HTMLElement | null): element is HTMLIFrameElement {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class EqualityHelperService {\r\n    areEqual(value1: string | any[] | object | null | undefined, value2: string | any[] | object | null | undefined) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysEqual(value1 as any[], value2 as any[]);\r\n        }\r\n\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n    }\r\n\r\n    private oneValueIsStringAndTheOtherIsArray(value1: string | object | any[], value2: string | object | any[]) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n\r\n    private bothValuesAreObjects(value1: string | object | any[], value2: string | object | any[]) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n\r\n    private bothValuesAreStrings(value1: string | object | any[], value2: string | object | any[]) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n\r\n    private bothValuesAreArrays(value1: string | object | any[], value2: string | object | any[]) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n\r\n    private valueIsString(value: any) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n\r\n    private valueIsObject(value: any) {\r\n        return typeof value === 'object';\r\n    }\r\n\r\n    private arraysEqual(arr1: Array<string>, arr2: Array<string>) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = arr1.length; i--; ) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { LoggerService } from './oidc.logger.service';\r\n\r\n@Injectable()\r\nexport class TokenHelperService {\r\n    private PARTS_OF_TOKEN = 3;\r\n    constructor(private readonly loggerService: LoggerService) { }\r\n\r\n    getTokenExpirationDate(dataIdToken: any): Date {\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            return new Date();\r\n        }\r\n\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n\r\n        return date;\r\n    }\r\n\r\n    getHeaderFromToken(token: any, encoded: boolean) {\r\n        if (!this.tokenIsValid(token)) {\r\n            return {};\r\n        }\r\n\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n\r\n    getPayloadFromToken(token: any, encoded: boolean) {\r\n        if (!this.tokenIsValid(token)) {\r\n            return {};\r\n        }\r\n\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n\r\n    getSignatureFromToken(token: any, encoded: boolean) {\r\n        if (!this.tokenIsValid(token)) {\r\n            return {};\r\n        }\r\n\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n\r\n    private getPartOfToken(token: string, index: number, encoded: boolean) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n\r\n    private urlBase64Decode(str: string) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n\r\n        const decoded = typeof window !== 'undefined' ? window.atob(output) : new Buffer(output, 'base64').toString('binary');\r\n\r\n        try {\r\n            // Going backwards: from bytestream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded.split('')\r\n                .map((c: string) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        } catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n\r\n    private tokenIsValid(token: string) {\r\n        if (!token) {\r\n            this.loggerService.logError(`token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n\r\n        if (!(token as string).includes('.')) {\r\n            this.loggerService.logError(`token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n\r\n        const parts = token.split('.');\r\n\r\n        if (parts.length !== this.PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(`token '${token}' is not valid --> token has to have exactly ${this.PARTS_OF_TOKEN} dots`);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private extractPartOfToken(token: string, index: number) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\n\r\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\n@Injectable()\r\nexport abstract class OidcSecurityStorage {\r\n    /**\r\n     * This method must contain the logic to read the storage.\r\n     * @param key\r\n     * @return The value of the given key\r\n     */\r\n    public abstract read(key: string): any;\r\n\r\n    /**\r\n     * This method must contain the logic to write the storage.\r\n     * @param key\r\n     * @param value The value for the given key\r\n     */\r\n    public abstract write(key: string, value: any): void;\r\n}\r\n\r\n@Injectable()\r\nexport class BrowserStorage implements OidcSecurityStorage {\r\n    private hasStorage: boolean;\r\n\r\n    constructor(private configProvider: ConfigurationProvider) {\r\n        this.hasStorage = typeof Storage !== 'undefined';\r\n    }\r\n\r\n    public read(key: string): any {\r\n        if (this.hasStorage) {\r\n            return JSON.parse(this.configProvider.openIDConfiguration.storage.getItem(key + '_' + this.configProvider.openIDConfiguration.client_id));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    public write(key: string, value: any): void {\r\n        if (this.hasStorage) {\r\n            value = value === undefined ? null : value;\r\n            this.configProvider.openIDConfiguration.storage.setItem(\r\n                key + '_' + this.configProvider.openIDConfiguration.client_id,\r\n                JSON.stringify(value)\r\n            );\r\n        }\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { OidcSecurityStorage } from './oidc.security.storage';\r\n\r\nexport type SilentRenewState = 'running' | '';\r\n\r\n@Injectable()\r\nexport class OidcSecurityCommon {\r\n    private storage_auth_result = 'authorizationResult';\r\n\r\n    public get authResult(): any {\r\n        return this.retrieve(this.storage_auth_result);\r\n    }\r\n\r\n    public set authResult(value: any) {\r\n        this.store(this.storage_auth_result, value);\r\n    }\r\n\r\n    private storage_access_token = 'authorizationData';\r\n\r\n    public get accessToken(): string {\r\n        return this.retrieve(this.storage_access_token) || '';\r\n    }\r\n\r\n    public set accessToken(value: string) {\r\n        this.store(this.storage_access_token, value);\r\n    }\r\n\r\n    private storage_id_token = 'authorizationDataIdToken';\r\n\r\n    public get idToken(): string {\r\n        return this.retrieve(this.storage_id_token) || '';\r\n    }\r\n\r\n    public set idToken(value: string) {\r\n        this.store(this.storage_id_token, value);\r\n    }\r\n\r\n    private storage_is_authorized = '_isAuthorized';\r\n\r\n    public get isAuthorized(): boolean | undefined {\r\n        return this.retrieve(this.storage_is_authorized);\r\n    }\r\n\r\n    public set isAuthorized(value: boolean | undefined) {\r\n        this.store(this.storage_is_authorized, value);\r\n    }\r\n\r\n    private storage_user_data = 'userData';\r\n\r\n    public get userData(): any {\r\n        return this.retrieve(this.storage_user_data);\r\n    }\r\n\r\n    public set userData(value: any) {\r\n        this.store(this.storage_user_data, value);\r\n    }\r\n\r\n    private storage_auth_nonce = 'authNonce';\r\n\r\n    public get authNonce(): string {\r\n        return this.retrieve(this.storage_auth_nonce) || '';\r\n    }\r\n\r\n    public set authNonce(value: string) {\r\n        this.store(this.storage_auth_nonce, value);\r\n    }\r\n\r\n    private storage_code_verifier = 'code_verifier';\r\n\r\n    public get code_verifier(): string {\r\n        return this.retrieve(this.storage_code_verifier) || '';\r\n    }\r\n\r\n    public set code_verifier(value: string) {\r\n        this.store(this.storage_code_verifier, value);\r\n    }\r\n\r\n    private storage_auth_state_control = 'authStateControl';\r\n\r\n    public get authStateControl(): string {\r\n        return this.retrieve(this.storage_auth_state_control) || '';\r\n    }\r\n\r\n    public set authStateControl(value: string) {\r\n        this.store(this.storage_auth_state_control, value);\r\n    }\r\n\r\n    private storage_session_state = 'session_state';\r\n\r\n    public get sessionState(): any {\r\n        return this.retrieve(this.storage_session_state);\r\n    }\r\n\r\n    public set sessionState(value: any) {\r\n        this.store(this.storage_session_state, value);\r\n    }\r\n\r\n    private storage_silent_renew_running = 'storage_silent_renew_running';\r\n\r\n    public get silentRenewRunning(): SilentRenewState {\r\n        return this.retrieve(this.storage_silent_renew_running) || '';\r\n    }\r\n\r\n    public set silentRenewRunning(value: SilentRenewState) {\r\n        this.store(this.storage_silent_renew_running, value);\r\n    }\r\n\r\n    private storage_custom_request_params = 'storage_custom_request_params';\r\n\r\n    public get customRequestParams(): {\r\n        [key: string]: string | number | boolean;\r\n    } {\r\n        return this.retrieve(this.storage_custom_request_params);\r\n    }\r\n\r\n    public set customRequestParams(value: { [key: string]: string | number | boolean }) {\r\n        this.store(this.storage_custom_request_params, value);\r\n    }\r\n\r\n    constructor(private oidcSecurityStorage: OidcSecurityStorage) { }\r\n\r\n    private retrieve(key: string): any {\r\n        return this.oidcSecurityStorage.read(key);\r\n    }\r\n\r\n    private store(key: string, value: any) {\r\n        this.oidcSecurityStorage.write(key, value);\r\n    }\r\n\r\n    resetStorageData(isRenewProcess: boolean) {\r\n        if (!isRenewProcess) {\r\n            this.store(this.storage_auth_result, '');\r\n            this.store(this.storage_session_state, '');\r\n            this.store(this.storage_silent_renew_running, '');\r\n            this.store(this.storage_is_authorized, false);\r\n            this.store(this.storage_access_token, '');\r\n            this.store(this.storage_id_token, '');\r\n            this.store(this.storage_user_data, '');\r\n            this.store(this.storage_code_verifier, '');\r\n        }\r\n    }\r\n\r\n    getAccessToken(): any {\r\n        return this.retrieve(this.storage_access_token);\r\n    }\r\n\r\n    getIdToken(): any {\r\n        return this.retrieve(this.storage_id_token);\r\n    }\r\n\r\n    getRefreshToken(): any {\r\n        return this.authResult.refresh_token;\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { hextob64u, KEYUTIL, KJUR } from 'jsrsasign-reduced';\r\nimport { EqualityHelperService } from './oidc-equality-helper.service';\r\nimport { TokenHelperService } from './oidc-token-helper.service';\r\nimport { LoggerService } from './oidc.logger.service';\r\n\r\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present in the ID Token.\r\n\r\n@Injectable()\r\nexport class OidcSecurityValidation {\r\n    static RefreshTokenNoncePlaceholder = '--RefreshToken--';\r\n\r\n    constructor(\r\n        private arrayHelperService: EqualityHelperService,\r\n        private tokenHelperService: TokenHelperService,\r\n        private loggerService: LoggerService\r\n    ) {}\r\n\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account for clock skew).\r\n    isTokenExpired(token: string, offsetSeconds?: number): boolean {\r\n        let decoded: any;\r\n        decoded = this.tokenHelperService.getPayloadFromToken(token, false);\r\n\r\n        return !this.validate_id_token_exp_not_expired(decoded, offsetSeconds);\r\n    }\r\n\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account for clock skew).\r\n    validate_id_token_exp_not_expired(decoded_id_token: string, offsetSeconds?: number): boolean {\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decoded_id_token);\r\n        offsetSeconds = offsetSeconds || 0;\r\n\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = new Date().valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n\r\n        this.loggerService.logDebug(`Token not expired?: ${tokenExpirationValue} > ${nowWithOffset}  (${tokenNotExpired})`);\r\n\r\n        // Token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured\r\n    // in UTC until the date/ time.\r\n    validate_required_id_token(dataIdToken: any): boolean {\r\n        let validated = true;\r\n        if (!dataIdToken.hasOwnProperty('iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning('iss is missing, this is required in the id_token');\r\n        }\r\n\r\n        if (!dataIdToken.hasOwnProperty('sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning('sub is missing, this is required in the id_token');\r\n        }\r\n\r\n        if (!dataIdToken.hasOwnProperty('aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning('aud is missing, this is required in the id_token');\r\n        }\r\n\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning('exp is missing, this is required in the id_token');\r\n        }\r\n\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning('iat is missing, this is required in the id_token');\r\n        }\r\n\r\n        return validated;\r\n    }\r\n\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validate_id_token_iat_max_offset(dataIdToken: any, max_offset_allowed_in_seconds: number, disable_iat_offset_validation: boolean): boolean {\r\n        if (disable_iat_offset_validation) {\r\n            return true;\r\n        }\r\n\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            return false;\r\n        }\r\n\r\n        const dateTime_iat_id_token = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTime_iat_id_token.setUTCSeconds(dataIdToken.iat);\r\n\r\n        max_offset_allowed_in_seconds = max_offset_allowed_in_seconds || 0;\r\n\r\n        if (dateTime_iat_id_token == null) {\r\n            return false;\r\n        }\r\n\r\n        this.loggerService.logDebug(\r\n            'validate_id_token_iat_max_offset: ' +\r\n                (new Date().valueOf() - dateTime_iat_id_token.valueOf()) +\r\n                ' < ' +\r\n                max_offset_allowed_in_seconds * 1000\r\n        );\r\n        return new Date().valueOf() - dateTime_iat_id_token.valueOf() < max_offset_allowed_in_seconds * 1000;\r\n    }\r\n\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n\r\n    // However the nonce claim SHOULD not be present for the refesh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and Keycloak does send it.\r\n    validate_id_token_nonce(dataIdToken: any, local_nonce: any, ignore_nonce_after_refresh: boolean): boolean {\r\n        const isFromRefreshToken =\r\n            (dataIdToken.nonce === undefined || ignore_nonce_after_refresh) && local_nonce === OidcSecurityValidation.RefreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== local_nonce) {\r\n            this.loggerService.logDebug('Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + local_nonce);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validate_id_token_iss(dataIdToken: any, authWellKnownEndpoints_issuer: any): boolean {\r\n        if ((dataIdToken.iss as string) !== (authWellKnownEndpoints_issuer as string)) {\r\n            this.loggerService.logDebug(\r\n                'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                    dataIdToken.iss +\r\n                    ' authWellKnownEndpoints issuer:' +\r\n                    authWellKnownEndpoints_issuer\r\n            );\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validate_id_token_aud(dataIdToken: any, aud: any): boolean {\r\n        if (dataIdToken.aud instanceof Array) {\r\n            const result = this.arrayHelperService.areEqual(dataIdToken.aud, aud);\r\n\r\n            if (!result) {\r\n                this.loggerService.logDebug('Validate_id_token_aud  array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        } else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug('Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    validateStateFromHashCallback(state: any, local_state: any): boolean {\r\n        if ((state as string) !== (local_state as string)) {\r\n            this.loggerService.logDebug('ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + local_state);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    validate_userdata_sub_id_token(id_token_sub: any, userdata_sub: any): boolean {\r\n        if ((id_token_sub as string) !== (userdata_sub as string)) {\r\n            this.loggerService.logDebug('validate_userdata_sub_id_token failed, id_token_sub: ' + id_token_sub + ' userdata_sub:' + userdata_sub);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validate_signature_id_token(id_token: any, jwtkeys: any): boolean {\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return false;\r\n        }\r\n\r\n        const header_data = this.tokenHelperService.getHeaderFromToken(id_token, false);\r\n\r\n        if (Object.keys(header_data).length === 0 && header_data.constructor === Object) {\r\n            this.loggerService.logWarning('id token has no header data');\r\n            return false;\r\n        }\r\n\r\n        const kid = header_data.kid;\r\n        const alg = header_data.alg;\r\n\r\n        if ('RS256' !== (alg as string)) {\r\n            this.loggerService.logWarning('Only RS256 supported');\r\n            return false;\r\n        }\r\n\r\n        let isValid = false;\r\n\r\n        if (!header_data.hasOwnProperty('kid')) {\r\n            // exactly 1 key in the jwtkeys and no kid in the Jose header\r\n            // kty\t\"RSA\" use \"sig\"\r\n            let amountOfMatchingKeys = 0;\r\n            for (const key of jwtkeys.keys) {\r\n                if ((key.kty as string) === 'RSA' && (key.use as string) === 'sig') {\r\n                    amountOfMatchingKeys = amountOfMatchingKeys + 1;\r\n                }\r\n            }\r\n\r\n            if (amountOfMatchingKeys === 0) {\r\n                this.loggerService.logWarning('no keys found, incorrect Signature, validation failed for id_token');\r\n                return false;\r\n            } else if (amountOfMatchingKeys > 1) {\r\n                this.loggerService.logWarning('no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\r\n                return false;\r\n            } else {\r\n                for (const key of jwtkeys.keys) {\r\n                    if ((key.kty as string) === 'RSA' && (key.use as string) === 'sig') {\r\n                        const publickey = KEYUTIL.getKey(key);\r\n                        isValid = KJUR.jws.JWS.verify(id_token, publickey, ['RS256']);\r\n                        if (!isValid) {\r\n                            this.loggerService.logWarning('incorrect Signature, validation failed for id_token');\r\n                        }\r\n                        return isValid;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // kid in the Jose header of id_token\r\n            for (const key of jwtkeys.keys) {\r\n                if ((key.kid as string) === (kid as string)) {\r\n                    const publickey = KEYUTIL.getKey(key);\r\n                    isValid = KJUR.jws.JWS.verify(id_token, publickey, ['RS256']);\r\n                    if (!isValid) {\r\n                        this.loggerService.logWarning('incorrect Signature, validation failed for id_token');\r\n                    }\r\n                    return isValid;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    }\r\n\r\n    config_validate_response_type(response_type: string): boolean {\r\n        if (response_type === 'id_token token' || response_type === 'id_token') {\r\n            return true;\r\n        }\r\n\r\n        if (response_type === 'code') {\r\n            return true;\r\n        }\r\n\r\n        this.loggerService.logWarning('module configure incorrect, invalid response_type:' + response_type);\r\n        return false;\r\n    }\r\n\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n\r\n    ////    return true;\r\n    //// }\r\n\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validate_id_token_at_hash(access_token: any, at_hash: any, isCodeFlow: boolean): boolean {\r\n        this.loggerService.logDebug('at_hash from the server:' + at_hash);\r\n\r\n        // The at_hash is optional for the code flow\r\n        if (isCodeFlow) {\r\n            if (!(at_hash as string)) {\r\n                this.loggerService.logDebug('Code Flow active, and no at_hash in the id_token, skipping check!');\r\n                return true;\r\n            }\r\n        }\r\n\r\n        const testdata = this.generate_at_hash('' + access_token);\r\n        this.loggerService.logDebug('at_hash client validation not decoded:' + testdata);\r\n        if (testdata === (at_hash as string)) {\r\n            return true; // isValid;\r\n        } else {\r\n            const testValue = this.generate_at_hash('' + decodeURIComponent(access_token));\r\n            this.loggerService.logDebug('-gen access--' + testValue);\r\n            if (testValue === (at_hash as string)) {\r\n                return true; // isValid\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private generate_at_hash(access_token: any): string {\r\n        const hash = KJUR.crypto.Util.hashString(access_token, 'sha256');\r\n        const first128bits = hash.substr(0, hash.length / 2);\r\n        const testdata = hextob64u(first128bits);\r\n\r\n        return testdata;\r\n    }\r\n\r\n    generate_code_verifier(code_challenge: any): string {\r\n        const hash = KJUR.crypto.Util.hashString(code_challenge, 'sha256');\r\n        const testdata = hextob64u(hash);\r\n\r\n        return testdata;\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { JwtKeys } from '../models/jwtkeys';\r\nimport { ValidateStateResult } from '../models/validate-state-result.model';\r\nimport { ValidationResult } from '../models/validation-result.enum';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\nimport { TokenHelperService } from './oidc-token-helper.service';\r\nimport { LoggerService } from './oidc.logger.service';\r\nimport { OidcSecurityCommon } from './oidc.security.common';\r\nimport { OidcSecurityValidation } from './oidc.security.validation';\r\n\r\n@Injectable()\r\nexport class StateValidationService {\r\n    constructor(\r\n        public oidcSecurityCommon: OidcSecurityCommon,\r\n        private oidcSecurityValidation: OidcSecurityValidation,\r\n        private tokenHelperService: TokenHelperService,\r\n        private loggerService: LoggerService,\r\n        private readonly configurationProvider: ConfigurationProvider\r\n    ) {}\r\n\r\n    validateState(result: any, jwtKeys: JwtKeys): ValidateStateResult {\r\n        const toReturn = new ValidateStateResult();\r\n        if (!this.oidcSecurityValidation.validateStateFromHashCallback(result.state, this.oidcSecurityCommon.authStateControl)) {\r\n            this.loggerService.logWarning('authorizedCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation();\r\n            return toReturn;\r\n        }\r\n\r\n        if (\r\n            this.configurationProvider.openIDConfiguration.response_type === 'id_token token' ||\r\n            this.configurationProvider.openIDConfiguration.response_type === 'code'\r\n        ) {\r\n            toReturn.access_token = result.access_token;\r\n        }\r\n\r\n        if (result.id_token) {\r\n            toReturn.id_token = result.id_token;\r\n\r\n            toReturn.decoded_id_token = this.tokenHelperService.getPayloadFromToken(toReturn.id_token, false);\r\n\r\n            if (!this.oidcSecurityValidation.validate_signature_id_token(toReturn.id_token, jwtKeys)) {\r\n                this.loggerService.logDebug('authorizedCallback Signature validation failed id_token');\r\n                toReturn.state = ValidationResult.SignatureFailed;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (\r\n                !this.oidcSecurityValidation.validate_id_token_nonce(\r\n                    toReturn.decoded_id_token,\r\n                    this.oidcSecurityCommon.authNonce,\r\n                    this.configurationProvider.openIDConfiguration.ignore_nonce_after_refresh\r\n                )\r\n            ) {\r\n                this.loggerService.logWarning('authorizedCallback incorrect nonce');\r\n                toReturn.state = ValidationResult.IncorrectNonce;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (!this.oidcSecurityValidation.validate_required_id_token(toReturn.decoded_id_token)) {\r\n                this.loggerService.logDebug('authorizedCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (\r\n                !this.oidcSecurityValidation.validate_id_token_iat_max_offset(\r\n                    toReturn.decoded_id_token,\r\n                    this.configurationProvider.openIDConfiguration.max_id_token_iat_offset_allowed_in_seconds,\r\n                    this.configurationProvider.openIDConfiguration.disable_iat_offset_validation\r\n                )\r\n            ) {\r\n                this.loggerService.logWarning('authorizedCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (this.configurationProvider.wellKnownEndpoints) {\r\n                if (this.configurationProvider.openIDConfiguration.iss_validation_off) {\r\n                    this.loggerService.logDebug('iss validation is turned off, this is not recommended!');\r\n                } else if (\r\n                    !this.configurationProvider.openIDConfiguration.iss_validation_off &&\r\n                    !this.oidcSecurityValidation.validate_id_token_iss(\r\n                        toReturn.decoded_id_token,\r\n                        this.configurationProvider.wellKnownEndpoints.issuer\r\n                    )\r\n                ) {\r\n                    this.loggerService.logWarning('authorizedCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                    toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                    this.handleUnsuccessfulValidation();\r\n                    return toReturn;\r\n                }\r\n            } else {\r\n                this.loggerService.logWarning('authWellKnownEndpoints is undefined');\r\n                toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (\r\n                !this.oidcSecurityValidation.validate_id_token_aud(\r\n                    toReturn.decoded_id_token,\r\n                    this.configurationProvider.openIDConfiguration.client_id\r\n                )\r\n            ) {\r\n                this.loggerService.logWarning('authorizedCallback incorrect aud');\r\n                toReturn.state = ValidationResult.IncorrectAud;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n\r\n            if (!this.oidcSecurityValidation.validate_id_token_exp_not_expired(toReturn.decoded_id_token)) {\r\n                this.loggerService.logWarning('authorizedCallback token expired');\r\n                toReturn.state = ValidationResult.TokenExpired;\r\n                this.handleUnsuccessfulValidation();\r\n                return toReturn;\r\n            }\r\n        } else {\r\n            this.loggerService.logDebug('No id_token found, skipping id_token validation');\r\n        }\r\n\r\n        // flow id_token token\r\n        if (\r\n            this.configurationProvider.openIDConfiguration.response_type !== 'id_token token' &&\r\n            this.configurationProvider.openIDConfiguration.response_type !== 'code'\r\n        ) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation();\r\n            this.handleUnsuccessfulValidation();\r\n            return toReturn;\r\n        }\r\n\r\n        if (\r\n            !this.oidcSecurityValidation.validate_id_token_at_hash(\r\n                toReturn.access_token,\r\n                toReturn.decoded_id_token.at_hash,\r\n                this.configurationProvider.openIDConfiguration.response_type === 'code'\r\n            ) ||\r\n            !toReturn.access_token\r\n        ) {\r\n            this.loggerService.logWarning('authorizedCallback incorrect at_hash');\r\n            toReturn.state = ValidationResult.IncorrectAtHash;\r\n            this.handleUnsuccessfulValidation();\r\n            return toReturn;\r\n        }\r\n\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation();\r\n        return toReturn;\r\n    }\r\n\r\n    private handleSuccessfulValidation() {\r\n        this.oidcSecurityCommon.authNonce = '';\r\n\r\n        if (this.configurationProvider.openIDConfiguration.auto_clean_state_after_authentication) {\r\n            this.oidcSecurityCommon.authStateControl = '';\r\n        }\r\n        this.loggerService.logDebug('AuthorizedCallback token(s) validated, continue');\r\n    }\r\n\r\n    private handleUnsuccessfulValidation() {\r\n        this.oidcSecurityCommon.authNonce = '';\r\n\r\n        if (this.configurationProvider.openIDConfiguration.auto_clean_state_after_authentication) {\r\n            this.oidcSecurityCommon.authStateControl = '';\r\n        }\r\n        this.loggerService.logDebug('AuthorizedCallback token(s) invalid');\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { from, Observable, Observer, Subject } from 'rxjs';\r\nimport { take } from 'rxjs/operators';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\nimport { IFrameService } from './existing-iframe.service';\r\nimport { LoggerService } from './oidc.logger.service';\r\nimport { OidcSecurityCommon } from './oidc.security.common';\r\n\r\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\n\r\n@Injectable()\r\nexport class OidcSecurityCheckSession {\r\n    private sessionIframe: any;\r\n    private iframeMessageEvent: any;\r\n    private scheduledHeartBeat: any;\r\n    private lastIFrameRefresh = 0;\r\n    private outstandingMessages = 0;\r\n    private heartBeatInterval = 3000;\r\n    private iframeRefreshInterval = 60000;\r\n    private _onCheckSessionChanged = new Subject<any>();\r\n\r\n    public get onCheckSessionChanged(): Observable<any> {\r\n        return this._onCheckSessionChanged.asObservable();\r\n    }\r\n\r\n    constructor(\r\n        private oidcSecurityCommon: OidcSecurityCommon,\r\n        private loggerService: LoggerService,\r\n        private iFrameService: IFrameService,\r\n        private zone: NgZone,\r\n        private readonly configurationProvider: ConfigurationProvider\r\n    ) {}\r\n\r\n    private doesSessionExist(): boolean {\r\n        const existingIFrame = this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n\r\n        if (!existingIFrame) {\r\n            return false;\r\n        }\r\n\r\n        this.sessionIframe = existingIFrame;\r\n        return true;\r\n    }\r\n\r\n    private init() {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return from([this]);\r\n        }\r\n\r\n        if (!this.doesSessionExist()) {\r\n            this.sessionIframe = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n            this.iframeMessageEvent = this.messageHandler.bind(this);\r\n            window.addEventListener('message', this.iframeMessageEvent, false);\r\n        }\r\n\r\n        if (!this.configurationProvider.wellKnownEndpoints) {\r\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return;\r\n        }\r\n\r\n        if (this.configurationProvider.wellKnownEndpoints.check_session_iframe) {\r\n            this.sessionIframe.contentWindow.location.replace(this.configurationProvider.wellKnownEndpoints.check_session_iframe);\r\n        } else {\r\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined');\r\n        }\r\n\r\n        return Observable.create((observer: Observer<OidcSecurityCheckSession>) => {\r\n            this.sessionIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next(this);\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n\r\n    startCheckingSession(clientId: string): void {\r\n        if (this.scheduledHeartBeat) {\r\n            return;\r\n        }\r\n\r\n        this.pollServerSession(clientId);\r\n    }\r\n\r\n    stopCheckingSession(): void {\r\n        if (!this.scheduledHeartBeat) {\r\n            return;\r\n        }\r\n\r\n        this.clearScheduledHeartBeat();\r\n    }\r\n\r\n    private pollServerSession(clientId: string) {\r\n        const _pollServerSessionRecur = () => {\r\n            this.init()\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                    if (this.sessionIframe && clientId) {\r\n                        this.loggerService.logDebug(this.sessionIframe);\r\n                        const session_state = this.oidcSecurityCommon.sessionState;\r\n                        if (session_state) {\r\n                            this.outstandingMessages++;\r\n                            this.sessionIframe.contentWindow.postMessage(\r\n                                clientId + ' ' + session_state,\r\n                                this.configurationProvider.openIDConfiguration.stsServer\r\n                            );\r\n                        } else {\r\n                            this.loggerService.logDebug('OidcSecurityCheckSession pollServerSession session_state is blank');\r\n                            this._onCheckSessionChanged.next();\r\n                        }\r\n                    } else {\r\n                        this.loggerService.logWarning('OidcSecurityCheckSession pollServerSession sessionIframe does not exist');\r\n                        this.loggerService.logDebug(clientId);\r\n                        this.loggerService.logDebug(this.sessionIframe);\r\n                        // this.init();\r\n                    }\r\n\r\n                    // after sending three messages with no response, fail.\r\n                    if (this.outstandingMessages > 3) {\r\n                        this.loggerService.logError(\r\n                            `OidcSecurityCheckSession not receiving check session response messages. Outstanding messages: ${\r\n                                this.outstandingMessages\r\n                            }. Server unreachable?`\r\n                        );\r\n                        this._onCheckSessionChanged.next();\r\n                    }\r\n\r\n                    this.scheduledHeartBeat = setTimeout(_pollServerSessionRecur, this.heartBeatInterval);\r\n                });\r\n        };\r\n\r\n        this.outstandingMessages = 0;\r\n\r\n        this.zone.runOutsideAngular(() => {\r\n            this.scheduledHeartBeat = setTimeout(_pollServerSessionRecur, this.heartBeatInterval);\r\n        });\r\n    }\r\n    private clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeat);\r\n        this.scheduledHeartBeat = null;\r\n    }\r\n\r\n    private messageHandler(e: any) {\r\n        this.outstandingMessages = 0;\r\n        if (\r\n            this.sessionIframe &&\r\n            e.origin === this.configurationProvider.openIDConfiguration.stsServer &&\r\n            e.source === this.sessionIframe.contentWindow\r\n        ) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning('error from checksession messageHandler');\r\n            } else if (e.data === 'changed') {\r\n                this._onCheckSessionChanged.next();\r\n            } else {\r\n                this.loggerService.logDebug(e.data + ' from checksession messageHandler');\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, of, ReplaySubject } from 'rxjs';\r\nimport { catchError, switchMap } from 'rxjs/operators';\r\nimport { LoggerService } from './oidc.logger.service';\r\n\r\nexport interface ConfigResult {\r\n    authWellknownEndpoints: any;\r\n    customConfig: any;\r\n}\r\n\r\n@Injectable()\r\nexport class OidcConfigService {\r\n    private configurationLoadedInternal = new ReplaySubject<ConfigResult>(1);\r\n\r\n    public get onConfigurationLoaded(): Observable<ConfigResult> {\r\n        return this.configurationLoadedInternal.asObservable();\r\n    }\r\n\r\n    constructor(private readonly loggerService: LoggerService, private readonly httpClient: HttpClient) { }\r\n\r\n    load(configUrl: string): Promise<boolean> {\r\n        return this.httpClient\r\n            .get(configUrl)\r\n            .pipe(\r\n                switchMap(clientConfiguration => {\r\n                    return this.loadUsingConfiguration(clientConfiguration);\r\n                }),\r\n                catchError(error => {\r\n                    this.loggerService.logError(`OidcConfigService 'load' threw an error on calling ${configUrl}`, error);\r\n                    this.configurationLoadedInternal.next(undefined);\r\n                    return of(false);\r\n                })\r\n            )\r\n            .toPromise();\r\n    }\r\n\r\n    load_using_stsServer(stsServer: string): Promise<boolean> {\r\n        return this.loadUsingConfiguration({ stsServer }).toPromise();\r\n    }\r\n\r\n    load_using_custom_stsServer(url: string): Promise<boolean> {\r\n        return this.httpClient\r\n            .get(url)\r\n            .pipe(\r\n                switchMap(wellKnownEndpoints => {\r\n                    this.configurationLoadedInternal.next({\r\n                        authWellknownEndpoints: wellKnownEndpoints,\r\n                        customConfig: { stsServer: url },\r\n                    });\r\n                    return of(true);\r\n                }),\r\n                catchError(error => {\r\n                    this.loggerService.logError(`OidcConfigService 'load_using_custom_stsServer' threw an error on calling ${url}`, error);\r\n                    this.configurationLoadedInternal.next(undefined);\r\n                    return of(false);\r\n                })\r\n            )\r\n            .toPromise();\r\n    }\r\n\r\n    private loadUsingConfiguration(clientConfig: any): Observable<boolean> {\r\n        if (!clientConfig.stsServer) {\r\n            this.loggerService.logError(`Property 'stsServer' is not present of passed config ${JSON.stringify(clientConfig)}`, clientConfig);\r\n            throw new Error(`Property 'stsServer' is not present of passed config ${JSON.stringify(clientConfig)}`);\r\n        }\r\n\r\n        const url = `${clientConfig.stsServer}/.well-known/openid-configuration`;\r\n\r\n        return this.httpClient.get(url).pipe(\r\n            switchMap(wellKnownEndpoints => {\r\n                this.configurationLoadedInternal.next({\r\n                    authWellknownEndpoints: wellKnownEndpoints,\r\n                    customConfig: clientConfig,\r\n                });\r\n                return of(true);\r\n            }),\r\n            catchError(error => {\r\n                this.loggerService.logError(`OidcConfigService 'load_using_stsServer' threw an error on calling ${url}`, error);\r\n                this.configurationLoadedInternal.next(undefined);\r\n                return of(false);\r\n            })\r\n        );\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IFrameService } from './existing-iframe.service';\r\nimport { LoggerService } from './oidc.logger.service';\r\n\r\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\n\r\n@Injectable()\r\nexport class OidcSecuritySilentRenew {\r\n    constructor(private loggerService: LoggerService, private iFrameService: IFrameService) {}\r\n\r\n    initRenew(): HTMLIFrameElement {\r\n        const existingIFrame = this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n        if (!existingIFrame) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n        }\r\n        return existingIFrame;\r\n    }\r\n\r\n    startRenew(url: string): Observable<void> {\r\n        const sessionIframe = this.initRenew();\r\n        this.loggerService.logDebug('startRenew for URL:' + url);\r\n        return new Observable<void>(observer => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                observer.next(undefined);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.src = url;\r\n            return () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n            };\r\n        });\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { OidcDataService } from '../data-services/oidc-data.service';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\nimport { LoggerService } from './oidc.logger.service';\r\nimport { OidcSecurityCommon } from './oidc.security.common';\r\n\r\n@Injectable()\r\nexport class OidcSecurityUserService {\r\n    private userData: any = '';\r\n\r\n    constructor(\r\n        private oidcDataService: OidcDataService,\r\n        private oidcSecurityCommon: OidcSecurityCommon,\r\n        private loggerService: LoggerService,\r\n        private readonly configurationProvider: ConfigurationProvider\r\n    ) {}\r\n\r\n    initUserData() {\r\n        return this.getIdentityUserData().pipe(map((data: any) => (this.userData = data)));\r\n    }\r\n\r\n    getUserData(): any {\r\n        if (!this.userData) {\r\n            throw Error('UserData is not set!');\r\n        }\r\n\r\n        return this.userData;\r\n    }\r\n\r\n    setUserData(value: any): void {\r\n        this.userData = value;\r\n    }\r\n\r\n    private getIdentityUserData(): Observable<any> {\r\n        const token = this.oidcSecurityCommon.getAccessToken();\r\n\r\n        if (!this.configurationProvider.wellKnownEndpoints) {\r\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined');\r\n\r\n            throw Error('authWellKnownEndpoints is undefined');\r\n        }\r\n\r\n        const canGetUserData =\r\n            this.configurationProvider.wellKnownEndpoints && this.configurationProvider.wellKnownEndpoints.userinfo_endpoint;\r\n\r\n        if (!canGetUserData) {\r\n            this.loggerService.logError(\r\n                'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config'\r\n            );\r\n            throw Error('authWellKnownEndpoints.userinfo_endpoint is undefined');\r\n        }\r\n\r\n        return this.oidcDataService.getIdentityUserData(this.configurationProvider.wellKnownEndpoints.userinfo_endpoint || '', token);\r\n    }\r\n}\r\n","import { HttpParameterCodec } from '@angular/common/http';\r\n\r\nexport class UriEncoder implements HttpParameterCodec {\r\n    encodeKey(key: string): string {\r\n        return encodeURIComponent(key);\r\n    }\r\n\r\n    encodeValue(value: string): string {\r\n        return encodeURIComponent(value);\r\n    }\r\n\r\n    decodeKey(key: string): string {\r\n        return decodeURIComponent(key);\r\n    }\r\n\r\n    decodeValue(value: string): string {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class UrlParserService {\r\n    getUrlParameter(urlToCheck: any, name: any): string {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n\r\n        if (!name) {\r\n            return '';\r\n        }\r\n\r\n        name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n}\r\n","import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Router } from '@angular/router';\r\nimport { BehaviorSubject, from, Observable, of, Subject, throwError, timer } from 'rxjs';\r\nimport { catchError, filter, map, race, shareReplay, switchMap, switchMapTo, take, tap } from 'rxjs/operators';\r\nimport { OidcDataService } from '../data-services/oidc-data.service';\r\nimport { OpenIdConfiguration } from '../models/auth.configuration';\r\nimport { AuthWellKnownEndpoints } from '../models/auth.well-known-endpoints';\r\nimport { AuthorizationResult } from '../models/authorization-result';\r\nimport { AuthorizationState } from '../models/authorization-state.enum';\r\nimport { JwtKeys } from '../models/jwtkeys';\r\nimport { ValidateStateResult } from '../models/validate-state-result.model';\r\nimport { ValidationResult } from '../models/validation-result.enum';\r\nimport { ConfigurationProvider } from './auth-configuration.provider';\r\nimport { StateValidationService } from './oidc-security-state-validation.service';\r\nimport { TokenHelperService } from './oidc-token-helper.service';\r\nimport { LoggerService } from './oidc.logger.service';\r\nimport { OidcSecurityCheckSession } from './oidc.security.check-session';\r\nimport { OidcSecurityCommon } from './oidc.security.common';\r\nimport { OidcSecuritySilentRenew } from './oidc.security.silent-renew';\r\nimport { OidcSecurityUserService } from './oidc.security.user-service';\r\nimport { OidcSecurityValidation } from './oidc.security.validation';\r\nimport { UriEncoder } from './uri-encoder';\r\nimport { UrlParserService } from './url-parser.service';\r\n\r\n@Injectable()\r\nexport class OidcSecurityService {\r\n    private _onModuleSetup = new Subject<boolean>();\r\n    private _onCheckSessionChanged = new Subject<boolean>();\r\n    private _onAuthorizationResult = new Subject<AuthorizationResult>();\r\n\r\n    public get onModuleSetup(): Observable<boolean> {\r\n        return this._onModuleSetup.asObservable();\r\n    }\r\n\r\n    public get onAuthorizationResult(): Observable<AuthorizationResult> {\r\n        return this._onAuthorizationResult.asObservable();\r\n    }\r\n\r\n    public get onCheckSessionChanged(): Observable<boolean> {\r\n        return this._onCheckSessionChanged.asObservable();\r\n    }\r\n\r\n    public get onConfigurationChange(): Observable<OpenIdConfiguration> {\r\n        return this.configurationProvider.onConfigurationChange;\r\n    }\r\n\r\n    checkSessionChanged = false;\r\n    moduleSetup = false;\r\n\r\n    private _isModuleSetup = new BehaviorSubject<boolean>(false);\r\n\r\n    private _isAuthorized = new BehaviorSubject<boolean>(false);\r\n    private _isSetupAndAuthorized: Observable<boolean>;\r\n\r\n    private _userData = new BehaviorSubject<any>('');\r\n    private authWellKnownEndpointsLoaded = false;\r\n    private runTokenValidationRunning = false;\r\n    private _scheduledHeartBeat: any;\r\n    private boundSilentRenewEvent: any;\r\n\r\n    constructor(\r\n        private oidcDataService: OidcDataService,\r\n        private stateValidationService: StateValidationService,\r\n        private router: Router,\r\n        private oidcSecurityCheckSession: OidcSecurityCheckSession,\r\n        private oidcSecuritySilentRenew: OidcSecuritySilentRenew,\r\n        private oidcSecurityUserService: OidcSecurityUserService,\r\n        private oidcSecurityCommon: OidcSecurityCommon,\r\n        private oidcSecurityValidation: OidcSecurityValidation,\r\n        private tokenHelperService: TokenHelperService,\r\n        private loggerService: LoggerService,\r\n        private zone: NgZone,\r\n        private readonly httpClient: HttpClient,\r\n        private readonly configurationProvider: ConfigurationProvider,\r\n        private readonly urlParserService: UrlParserService\r\n    ) {\r\n        this.onModuleSetup.pipe(take(1)).subscribe(() => {\r\n            this.moduleSetup = true;\r\n            this._isModuleSetup.next(true);\r\n        });\r\n\r\n        this._isSetupAndAuthorized = this._isModuleSetup.pipe(\r\n            filter((isModuleSetup: boolean) => isModuleSetup),\r\n            switchMap(() => {\r\n                if (!this.configurationProvider.openIDConfiguration.silent_renew) {\r\n                    this.loggerService.logDebug(`IsAuthorizedRace: Silent Renew Not Active. Emitting.`);\r\n                    return from([true]);\r\n                }\r\n\r\n                const race$ = this._isAuthorized.asObservable().pipe(\r\n                    filter((isAuthorized: boolean) => isAuthorized),\r\n                    take(1),\r\n                    tap(() => this.loggerService.logDebug('IsAuthorizedRace: Existing token is still authorized.')),\r\n                    race(\r\n                        this._onAuthorizationResult.pipe(\r\n                            take(1),\r\n                            tap(() => this.loggerService.logDebug('IsAuthorizedRace: Silent Renew Refresh Session Complete')),\r\n                            map(() => true)\r\n                        ),\r\n                        timer(this.configurationProvider.openIDConfiguration.isauthorizedrace_timeout_in_seconds * 1000).pipe(\r\n                            // backup, if nothing happens after X seconds stop waiting and emit (5s Default)\r\n                            tap(() => {\r\n                                this.resetAuthorizationData(false);\r\n                                this.oidcSecurityCommon.authNonce = '';\r\n                                this.loggerService.logWarning('IsAuthorizedRace: Timeout reached. Emitting.');\r\n                            }),\r\n                            map(() => true)\r\n                        )\r\n                    )\r\n                );\r\n\r\n                this.loggerService.logDebug('Silent Renew is active, check if token in storage is active');\r\n                if (this.oidcSecurityCommon.authNonce === '' || this.oidcSecurityCommon.authNonce === undefined) {\r\n                    // login not running, or a second silent renew, user must login first before this will work.\r\n                    this.loggerService.logDebug('Silent Renew or login not running, try to refresh the session');\r\n                    this.refreshSession().subscribe();\r\n                }\r\n\r\n                return race$;\r\n            }),\r\n            tap(() => this.loggerService.logDebug('IsAuthorizedRace: Completed')),\r\n            switchMapTo(this._isAuthorized.asObservable()),\r\n            tap((isAuthorized: boolean) => this.loggerService.logDebug(`getIsAuthorized: ${isAuthorized}`)),\r\n            shareReplay(1)\r\n        );\r\n\r\n        this._isSetupAndAuthorized\r\n            .pipe(filter(() => this.configurationProvider.openIDConfiguration.start_checksession))\r\n            .subscribe(isSetupAndAuthorized => {\r\n                if (isSetupAndAuthorized) {\r\n                    this.oidcSecurityCheckSession.startCheckingSession(this.configurationProvider.openIDConfiguration.client_id);\r\n                } else {\r\n                    this.oidcSecurityCheckSession.stopCheckingSession();\r\n                }\r\n            });\r\n    }\r\n\r\n    setupModule(openIdConfiguration: OpenIdConfiguration, authWellKnownEndpoints: AuthWellKnownEndpoints): void {\r\n        this.configurationProvider.setup(openIdConfiguration, authWellKnownEndpoints);\r\n\r\n        this.oidcSecurityCheckSession.onCheckSessionChanged.subscribe(() => {\r\n            this.loggerService.logDebug('onCheckSessionChanged');\r\n            this.checkSessionChanged = true;\r\n            this._onCheckSessionChanged.next(this.checkSessionChanged);\r\n        });\r\n\r\n        const userData = this.oidcSecurityCommon.userData;\r\n        if (userData) {\r\n            this.setUserData(userData);\r\n        }\r\n\r\n        const isAuthorized = this.oidcSecurityCommon.isAuthorized;\r\n        if (isAuthorized) {\r\n            this.loggerService.logDebug('IsAuthorized setup module');\r\n            this.loggerService.logDebug(this.oidcSecurityCommon.idToken);\r\n            if (\r\n                this.oidcSecurityValidation.isTokenExpired(\r\n                    this.oidcSecurityCommon.idToken || this.oidcSecurityCommon.accessToken,\r\n                    this.configurationProvider.openIDConfiguration.silent_renew_offset_in_seconds\r\n                )\r\n            ) {\r\n                this.loggerService.logDebug('IsAuthorized setup module; id_token isTokenExpired');\r\n            } else {\r\n                this.loggerService.logDebug('IsAuthorized setup module; id_token is valid');\r\n                this.setIsAuthorized(isAuthorized);\r\n            }\r\n            this.runTokenValidation();\r\n        }\r\n\r\n        this.loggerService.logDebug('STS server: ' + this.configurationProvider.openIDConfiguration.stsServer);\r\n\r\n        this._onModuleSetup.next();\r\n\r\n        if (this.configurationProvider.openIDConfiguration.silent_renew) {\r\n            this.oidcSecuritySilentRenew.initRenew();\r\n\r\n            // Support authorization via DOM events.\r\n            // Deregister if OidcSecurityService.setupModule is called again by any instance.\r\n            //      We only ever want the latest setup service to be reacting to this event.\r\n            this.boundSilentRenewEvent = this.silentRenewEventHandler.bind(this);\r\n\r\n            const instanceId = Math.random();\r\n\r\n            const boundSilentRenewInitEvent: any = ((e: CustomEvent) => {\r\n                if (e.detail !== instanceId) {\r\n                    window.removeEventListener('oidc-silent-renew-message', this.boundSilentRenewEvent);\r\n                    window.removeEventListener('oidc-silent-renew-init', boundSilentRenewInitEvent);\r\n                }\r\n            }).bind(this);\r\n\r\n            window.addEventListener('oidc-silent-renew-init', boundSilentRenewInitEvent, false);\r\n            window.addEventListener('oidc-silent-renew-message', this.boundSilentRenewEvent, false);\r\n\r\n            window.dispatchEvent(\r\n                new CustomEvent('oidc-silent-renew-init', {\r\n                    detail: instanceId,\r\n                })\r\n            );\r\n        }\r\n    }\r\n\r\n    getUserData<T = any>(): Observable<T> {\r\n        return this._userData.asObservable();\r\n    }\r\n\r\n    getIsModuleSetup(): Observable<boolean> {\r\n        return this._isModuleSetup.asObservable();\r\n    }\r\n\r\n    getIsAuthorized(): Observable<boolean> {\r\n        return this._isSetupAndAuthorized;\r\n    }\r\n\r\n    getToken(): string {\r\n        if (!this._isAuthorized.getValue()) {\r\n            return '';\r\n        }\r\n\r\n        const token = this.oidcSecurityCommon.getAccessToken();\r\n        return decodeURIComponent(token);\r\n    }\r\n\r\n    getIdToken(): string {\r\n        if (!this._isAuthorized.getValue()) {\r\n            return '';\r\n        }\r\n\r\n        const token = this.oidcSecurityCommon.getIdToken();\r\n        return decodeURIComponent(token);\r\n    }\r\n\r\n    getRefreshToken(): string {\r\n        if (!this._isAuthorized.getValue()) {\r\n            return '';\r\n        }\r\n\r\n        const token = this.oidcSecurityCommon.getRefreshToken();\r\n        return decodeURIComponent(token);\r\n    }\r\n\r\n    getPayloadFromIdToken(encode = false): any {\r\n        const token = this.getIdToken();\r\n        return this.tokenHelperService.getPayloadFromToken(token, encode);\r\n    }\r\n\r\n    setState(state: string): void {\r\n        this.oidcSecurityCommon.authStateControl = state;\r\n    }\r\n\r\n    getState(): string {\r\n        return this.oidcSecurityCommon.authStateControl;\r\n    }\r\n\r\n    setCustomRequestParameters(params: { [key: string]: string | number | boolean }) {\r\n        this.oidcSecurityCommon.customRequestParams = params;\r\n    }\r\n\r\n    // Code Flow with PCKE or Implicit Flow\r\n    authorize(urlHandler?: (url: string) => any) {\r\n        if (this.configurationProvider.wellKnownEndpoints) {\r\n            this.authWellKnownEndpointsLoaded = true;\r\n        }\r\n\r\n        if (!this.authWellKnownEndpointsLoaded) {\r\n            this.loggerService.logError('Well known endpoints must be loaded before user can login!');\r\n            return;\r\n        }\r\n\r\n        if (!this.oidcSecurityValidation.config_validate_response_type(this.configurationProvider.openIDConfiguration.response_type)) {\r\n            // invalid response_type\r\n            return;\r\n        }\r\n\r\n        this.resetAuthorizationData(false);\r\n\r\n        this.loggerService.logDebug('BEGIN Authorize Code Flow, no auth data');\r\n\r\n        let state = this.oidcSecurityCommon.authStateControl;\r\n        if (!state) {\r\n            state = Date.now() + '' + Math.random() + Math.random();\r\n            this.oidcSecurityCommon.authStateControl = state;\r\n        }\r\n\r\n        const nonce = 'N' + Math.random() + '' + Date.now();\r\n        this.oidcSecurityCommon.authNonce = nonce;\r\n        this.loggerService.logDebug('AuthorizedController created. local state: ' + this.oidcSecurityCommon.authStateControl);\r\n\r\n        let url = '';\r\n        // Code Flow\r\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\r\n            // code_challenge with \"S256\"\r\n            const code_verifier = 'C' + Math.random() + '' + Date.now() + '' + Date.now() + Math.random();\r\n            const code_challenge = this.oidcSecurityValidation.generate_code_verifier(code_verifier);\r\n\r\n            this.oidcSecurityCommon.code_verifier = code_verifier;\r\n\r\n            if (this.configurationProvider.wellKnownEndpoints) {\r\n                url = this.createAuthorizeUrl(\r\n                    true,\r\n                    code_challenge,\r\n                    this.configurationProvider.openIDConfiguration.redirect_url,\r\n                    nonce,\r\n                    state,\r\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || ''\r\n                );\r\n            } else {\r\n                this.loggerService.logError('authWellKnownEndpoints is undefined');\r\n            }\r\n        } else {\r\n            // Implicit Flow\r\n\r\n            if (this.configurationProvider.wellKnownEndpoints) {\r\n                url = this.createAuthorizeUrl(\r\n                    false,\r\n                    '',\r\n                    this.configurationProvider.openIDConfiguration.redirect_url,\r\n                    nonce,\r\n                    state,\r\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || ''\r\n                );\r\n            } else {\r\n                this.loggerService.logError('authWellKnownEndpoints is undefined');\r\n            }\r\n        }\r\n\r\n        if (urlHandler) {\r\n            urlHandler(url);\r\n        } else {\r\n            this.redirectTo(url);\r\n        }\r\n    }\r\n\r\n    // Code Flow\r\n    authorizedCallbackWithCode(urlToCheck: string) {\r\n        this.authorizedCallbackWithCode$(urlToCheck).subscribe();\r\n    }\r\n    authorizedCallbackWithCode$(urlToCheck: string): Observable<void> {\r\n        const code = this.urlParserService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlParserService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlParserService.getUrlParameter(urlToCheck, 'session_state') || null;\r\n\r\n        if (!state) {\r\n            this.loggerService.logDebug('no state in url');\r\n            return of();\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug('no code in url');\r\n            return of();\r\n        }\r\n        this.loggerService.logDebug('running validation for callback' + urlToCheck);\r\n        return this.requestTokensWithCode$(code, state, sessionState);\r\n    }\r\n\r\n    // Code Flow\r\n    requestTokensWithCode(code: string, state: string, sessionState: string | null): void {\r\n        this.requestTokensWithCode$(code, state, sessionState).subscribe();\r\n    }\r\n\r\n    requestTokensWithCode$(code: string, state: string, sessionState: string | null): Observable<void> {\r\n        return this._isModuleSetup.pipe(\r\n            filter(isModuleSetup => !!isModuleSetup),\r\n            take(1),\r\n            switchMap(() => {\r\n                return this.requestTokensWithCodeProcedure$(code, state, sessionState);\r\n            })\r\n        );\r\n    }\r\n\r\n    // Refresh Token\r\n    refreshTokensWithCodeProcedure(code: string, state: string): Observable<any> {\r\n        let tokenRequestUrl = '';\r\n        if (this.configurationProvider.wellKnownEndpoints && this.configurationProvider.wellKnownEndpoints.token_endpoint) {\r\n            tokenRequestUrl = `${this.configurationProvider.wellKnownEndpoints.token_endpoint}`;\r\n        }\r\n\r\n        let headers: HttpHeaders = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n\r\n        const data = `grant_type=refresh_token&client_id=${this.configurationProvider.openIDConfiguration.client_id}` + `&refresh_token=${code}`;\r\n\r\n        return this.httpClient.post(tokenRequestUrl, data, { headers }).pipe(\r\n            map(response => {\r\n                this.loggerService.logDebug('token refresh response: ' + JSON.stringify(response));\r\n                let obj: any = new Object();\r\n                obj = response;\r\n                obj.state = state;\r\n\r\n                this.authorizedCodeFlowCallbackProcedure(obj);\r\n            }),\r\n            catchError(error => {\r\n                this.loggerService.logError(error);\r\n                this.loggerService.logError(`OidcService code request ${this.configurationProvider.openIDConfiguration.stsServer}`);\r\n                return of(false);\r\n            })\r\n        );\r\n    }\r\n\r\n    requestTokensWithCodeProcedure(code: string, state: string, session_state: string | null): void {\r\n        this.requestTokensWithCodeProcedure$(code, state, session_state).subscribe();\r\n    }\r\n\r\n    // Code Flow with PCKE\r\n    requestTokensWithCodeProcedure$(code: string, state: string, session_state: string | null): Observable<void> {\r\n        let tokenRequestUrl = '';\r\n        if (this.configurationProvider.wellKnownEndpoints && this.configurationProvider.wellKnownEndpoints.token_endpoint) {\r\n            tokenRequestUrl = `${this.configurationProvider.wellKnownEndpoints.token_endpoint}`;\r\n        }\r\n\r\n        if (!this.oidcSecurityValidation.validateStateFromHashCallback(state, this.oidcSecurityCommon.authStateControl)) {\r\n            this.loggerService.logWarning('authorizedCallback incorrect state');\r\n            // ValidationResult.StatesDoNotMatch;\r\n            return throwError(new Error('incorrect state'));\r\n        }\r\n\r\n        let headers: HttpHeaders = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n\r\n        let data =\r\n            `grant_type=authorization_code&client_id=${this.configurationProvider.openIDConfiguration.client_id}` +\r\n            `&code_verifier=${this.oidcSecurityCommon.code_verifier}&code=${code}&redirect_uri=${this.configurationProvider.openIDConfiguration.redirect_url}`;\r\n        if (this.oidcSecurityCommon.silentRenewRunning === 'running') {\r\n            data =\r\n                `grant_type=authorization_code&client_id=${this.configurationProvider.openIDConfiguration.client_id}` +\r\n                `&code_verifier=${this.oidcSecurityCommon.code_verifier}&code=${code}&redirect_uri=${this.configurationProvider.openIDConfiguration.silent_renew_url}`;\r\n        }\r\n\r\n        return this.httpClient.post(tokenRequestUrl, data, { headers: headers }).pipe(\r\n            map(response => {\r\n                let obj: any = new Object();\r\n                obj = response;\r\n                obj.state = state;\r\n                obj.session_state = session_state;\r\n\r\n                this.authorizedCodeFlowCallbackProcedure(obj);\r\n\r\n                return undefined;\r\n            }),\r\n            catchError(error => {\r\n                this.loggerService.logError(error);\r\n                this.loggerService.logError(`OidcService code request ${this.configurationProvider.openIDConfiguration.stsServer}`);\r\n                return throwError(error);\r\n            })\r\n        );\r\n    }\r\n\r\n    // Code Flow\r\n    private authorizedCodeFlowCallbackProcedure(result: any) {\r\n        const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\r\n        const isRenewProcess = silentRenew === 'running';\r\n\r\n        this.loggerService.logDebug('BEGIN authorized Code Flow Callback, no auth data');\r\n        this.resetAuthorizationData(isRenewProcess);\r\n        this.authorizedCallbackProcedure(result, isRenewProcess);\r\n    }\r\n\r\n    // Implicit Flow\r\n    private authorizedImplicitFlowCallbackProcedure(hash?: string) {\r\n        const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\r\n        const isRenewProcess = silentRenew === 'running';\r\n\r\n        this.loggerService.logDebug('BEGIN authorizedCallback, no auth data');\r\n        this.resetAuthorizationData(isRenewProcess);\r\n\r\n        hash = hash || window.location.hash.substr(1);\r\n\r\n        const result: any = hash.split('&').reduce(function(resultData: any, item: string) {\r\n            const parts = item.split('=');\r\n            resultData[<string>parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        this.authorizedCallbackProcedure(result, isRenewProcess);\r\n    }\r\n\r\n    // Implicit Flow\r\n    authorizedImplicitFlowCallback(hash?: string) {\r\n        this._isModuleSetup\r\n            .pipe(\r\n                filter((isModuleSetup: boolean) => isModuleSetup),\r\n                take(1)\r\n            )\r\n            .subscribe(() => {\r\n                this.authorizedImplicitFlowCallbackProcedure(hash);\r\n            });\r\n    }\r\n\r\n    private redirectTo(url: string) {\r\n        window.location.href = url;\r\n    }\r\n\r\n    // Implicit Flow\r\n    private authorizedCallbackProcedure(result: any, isRenewProcess: boolean) {\r\n        this.oidcSecurityCommon.authResult = result;\r\n\r\n        if (!this.configurationProvider.openIDConfiguration.history_cleanup_off && !isRenewProcess) {\r\n            // reset the history to remove the tokens\r\n            window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\r\n        } else {\r\n            this.loggerService.logDebug('history clean up inactive');\r\n        }\r\n\r\n        if (result.error) {\r\n            if (isRenewProcess) {\r\n                this.loggerService.logDebug(result);\r\n            } else {\r\n                this.loggerService.logWarning(result);\r\n            }\r\n\r\n            if ((result.error as string) === 'login_required') {\r\n                this._onAuthorizationResult.next(\r\n                    new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.LoginRequired, isRenewProcess)\r\n                );\r\n            } else {\r\n                this._onAuthorizationResult.next(\r\n                    new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.SecureTokenServerError, isRenewProcess)\r\n                );\r\n            }\r\n\r\n            this.resetAuthorizationData(false);\r\n            this.oidcSecurityCommon.authNonce = '';\r\n\r\n            if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\r\n                this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\r\n            }\r\n        } else {\r\n            this.loggerService.logDebug(result);\r\n\r\n            this.loggerService.logDebug('authorizedCallback created, begin token validation');\r\n\r\n            this.getSigningKeys().subscribe(\r\n                jwtKeys => {\r\n                    const validationResult = this.getValidatedStateResult(result, jwtKeys);\r\n\r\n                    if (validationResult.authResponseIsValid) {\r\n                        this.setAuthorizationData(validationResult.access_token, validationResult.id_token);\r\n                        this.oidcSecurityCommon.silentRenewRunning = '';\r\n\r\n                        if (this.configurationProvider.openIDConfiguration.auto_userinfo) {\r\n                            this.getUserinfo(isRenewProcess, result, validationResult.id_token, validationResult.decoded_id_token).subscribe(\r\n                                response => {\r\n                                    if (response) {\r\n                                        this._onAuthorizationResult.next(\r\n                                            new AuthorizationResult(AuthorizationState.authorized, validationResult.state, isRenewProcess)\r\n                                        );\r\n                                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\r\n                                            this.router.navigate([this.configurationProvider.openIDConfiguration.post_login_route]);\r\n                                        }\r\n                                    } else {\r\n                                        this._onAuthorizationResult.next(\r\n                                            new AuthorizationResult(AuthorizationState.unauthorized, validationResult.state, isRenewProcess)\r\n                                        );\r\n                                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\r\n                                            this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\r\n                                        }\r\n                                    }\r\n                                },\r\n                                err => {\r\n                                    /* Something went wrong while getting signing key */\r\n                                    this.loggerService.logWarning('Failed to retreive user info with error: ' + JSON.stringify(err));\r\n                                }\r\n                            );\r\n                        } else {\r\n                            if (!isRenewProcess) {\r\n                                // userData is set to the id_token decoded, auto get user data set to false\r\n                                this.oidcSecurityUserService.setUserData(validationResult.decoded_id_token);\r\n                                this.setUserData(this.oidcSecurityUserService.getUserData());\r\n                            }\r\n\r\n                            this.runTokenValidation();\r\n\r\n                            this._onAuthorizationResult.next(\r\n                                new AuthorizationResult(AuthorizationState.authorized, validationResult.state, isRenewProcess)\r\n                            );\r\n                            if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\r\n                                this.router.navigate([this.configurationProvider.openIDConfiguration.post_login_route]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // something went wrong\r\n                        this.loggerService.logWarning('authorizedCallback, token(s) validation failed, resetting');\r\n                        this.loggerService.logWarning(window.location.hash);\r\n                        this.resetAuthorizationData(false);\r\n                        this.oidcSecurityCommon.silentRenewRunning = '';\r\n\r\n                        this._onAuthorizationResult.next(\r\n                            new AuthorizationResult(AuthorizationState.unauthorized, validationResult.state, isRenewProcess)\r\n                        );\r\n                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\r\n                            this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\r\n                        }\r\n                    }\r\n                },\r\n                err => {\r\n                    /* Something went wrong while getting signing key */\r\n                    this.loggerService.logWarning('Failed to retreive siging key with error: ' + JSON.stringify(err));\r\n                    this.oidcSecurityCommon.silentRenewRunning = '';\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    getUserinfo(isRenewProcess = false, result?: any, id_token?: any, decoded_id_token?: any): Observable<boolean> {\r\n        result = result ? result : this.oidcSecurityCommon.authResult;\r\n        id_token = id_token ? id_token : this.oidcSecurityCommon.idToken;\r\n        decoded_id_token = decoded_id_token ? decoded_id_token : this.tokenHelperService.getPayloadFromToken(id_token, false);\r\n\r\n        return new Observable<boolean>(observer => {\r\n            // flow id_token token\r\n            if (\r\n                this.configurationProvider.openIDConfiguration.response_type === 'id_token token' ||\r\n                this.configurationProvider.openIDConfiguration.response_type === 'code'\r\n            ) {\r\n                if (isRenewProcess && this._userData.value) {\r\n                    this.oidcSecurityCommon.sessionState = result.session_state;\r\n                    observer.next(true);\r\n                    observer.complete();\r\n                } else {\r\n                    this.oidcSecurityUserService.initUserData().subscribe(() => {\r\n                        this.loggerService.logDebug('authorizedCallback (id_token token || code) flow');\r\n\r\n                        const userData = this.oidcSecurityUserService.getUserData();\r\n\r\n                        if (this.oidcSecurityValidation.validate_userdata_sub_id_token(decoded_id_token.sub, userData.sub)) {\r\n                            this.setUserData(userData);\r\n                            this.loggerService.logDebug(this.oidcSecurityCommon.accessToken);\r\n                            this.loggerService.logDebug(this.oidcSecurityUserService.getUserData());\r\n\r\n                            this.oidcSecurityCommon.sessionState = result.session_state;\r\n\r\n                            this.runTokenValidation();\r\n                            observer.next(true);\r\n                        } else {\r\n                            // something went wrong, userdata sub does not match that from id_token\r\n                            this.loggerService.logWarning('authorizedCallback, User data sub does not match sub in id_token');\r\n                            this.loggerService.logDebug('authorizedCallback, token(s) validation failed, resetting');\r\n                            this.resetAuthorizationData(false);\r\n                            observer.next(false);\r\n                        }\r\n                        observer.complete();\r\n                    });\r\n                }\r\n            } else {\r\n                // flow id_token\r\n                this.loggerService.logDebug('authorizedCallback id_token flow');\r\n                this.loggerService.logDebug(this.oidcSecurityCommon.accessToken);\r\n\r\n                // userData is set to the id_token decoded. No access_token.\r\n                this.oidcSecurityUserService.setUserData(decoded_id_token);\r\n                this.setUserData(this.oidcSecurityUserService.getUserData());\r\n\r\n                this.oidcSecurityCommon.sessionState = result.session_state;\r\n\r\n                this.runTokenValidation();\r\n\r\n                observer.next(true);\r\n                observer.complete();\r\n            }\r\n        });\r\n    }\r\n\r\n    logoff(urlHandler?: (url: string) => any) {\r\n        // /connect/endsession?id_token_hint=...&post_logout_redirect_uri=https://myapp.com\r\n        this.loggerService.logDebug('BEGIN Authorize, no auth data');\r\n\r\n        if (this.configurationProvider.wellKnownEndpoints) {\r\n            if (this.configurationProvider.wellKnownEndpoints.end_session_endpoint) {\r\n                const end_session_endpoint = this.configurationProvider.wellKnownEndpoints.end_session_endpoint;\r\n                const id_token_hint = this.oidcSecurityCommon.idToken;\r\n                const url = this.createEndSessionUrl(end_session_endpoint, id_token_hint);\r\n\r\n                this.resetAuthorizationData(false);\r\n\r\n                if (this.configurationProvider.openIDConfiguration.start_checksession && this.checkSessionChanged) {\r\n                    this.loggerService.logDebug('only local login cleaned up, server session has changed');\r\n                } else if (urlHandler) {\r\n                    urlHandler(url);\r\n                } else {\r\n                    this.redirectTo(url);\r\n                }\r\n            } else {\r\n                this.resetAuthorizationData(false);\r\n                this.loggerService.logDebug('only local login cleaned up, no end_session_endpoint');\r\n            }\r\n        } else {\r\n            this.loggerService.logWarning('authWellKnownEndpoints is undefined');\r\n        }\r\n    }\r\n\r\n    refreshSession(): Observable<boolean> {\r\n        if (!this.configurationProvider.openIDConfiguration.silent_renew) {\r\n            return of(false);\r\n        }\r\n\r\n        this.loggerService.logDebug('BEGIN refresh session Authorize');\r\n\r\n        let state = this.oidcSecurityCommon.authStateControl;\r\n        if (state === '' || state === null) {\r\n            state = Date.now() + '' + Math.random() + Math.random();\r\n            this.oidcSecurityCommon.authStateControl = state;\r\n        }\r\n\r\n        const nonce = 'N' + Math.random() + '' + Date.now();\r\n        this.oidcSecurityCommon.authNonce = nonce;\r\n        this.loggerService.logDebug('RefreshSession created. adding myautostate: ' + this.oidcSecurityCommon.authStateControl);\r\n\r\n        let url = '';\r\n\r\n        // Code Flow\r\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\r\n            if (this.configurationProvider.openIDConfiguration.use_refresh_token) {\r\n                // try using refresh token\r\n                const refresh_token = this.oidcSecurityCommon.getRefreshToken();\r\n                if (refresh_token) {\r\n                    this.loggerService.logDebug('found refresh code, obtaining new credentials with refresh code');\r\n                    // Nonce is not used with refresh tokens; but Keycloak may send it anyway\r\n                    this.oidcSecurityCommon.authNonce = OidcSecurityValidation.RefreshTokenNoncePlaceholder;\r\n                    return this.refreshTokensWithCodeProcedure(refresh_token, state);\r\n                } else {\r\n                    this.loggerService.logDebug('no refresh token found, using silent renew');\r\n                }\r\n            }\r\n            // code_challenge with \"S256\"\r\n            const code_verifier = 'C' + Math.random() + '' + Date.now() + '' + Date.now() + Math.random();\r\n            const code_challenge = this.oidcSecurityValidation.generate_code_verifier(code_verifier);\r\n\r\n            this.oidcSecurityCommon.code_verifier = code_verifier;\r\n\r\n            if (this.configurationProvider.wellKnownEndpoints) {\r\n                url = this.createAuthorizeUrl(\r\n                    true,\r\n                    code_challenge,\r\n                    this.configurationProvider.openIDConfiguration.silent_renew_url,\r\n                    nonce,\r\n                    state,\r\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || '',\r\n                    'none'\r\n                );\r\n            } else {\r\n                this.loggerService.logWarning('authWellKnownEndpoints is undefined');\r\n            }\r\n        } else {\r\n            if (this.configurationProvider.wellKnownEndpoints) {\r\n                url = this.createAuthorizeUrl(\r\n                    false,\r\n                    '',\r\n                    this.configurationProvider.openIDConfiguration.silent_renew_url,\r\n                    nonce,\r\n                    state,\r\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || '',\r\n                    'none'\r\n                );\r\n            } else {\r\n                this.loggerService.logWarning('authWellKnownEndpoints is undefined');\r\n            }\r\n        }\r\n\r\n        this.oidcSecurityCommon.silentRenewRunning = 'running';\r\n        return this.oidcSecuritySilentRenew.startRenew(url).pipe(map(() => true));\r\n    }\r\n\r\n    handleError(error: any) {\r\n        const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\r\n        const isRenewProcess = silentRenew === 'running';\r\n        this.loggerService.logError(error);\r\n        if (error.status === 403 || error.status === '403') {\r\n            if (this.configurationProvider.openIDConfiguration.trigger_authorization_result_event) {\r\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.NotSet, isRenewProcess));\r\n            } else {\r\n                this.router.navigate([this.configurationProvider.openIDConfiguration.forbidden_route]);\r\n            }\r\n        } else if (error.status === 401 || error.status === '401') {\r\n            const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\r\n\r\n            this.resetAuthorizationData(!!silentRenew);\r\n\r\n            if (this.configurationProvider.openIDConfiguration.trigger_authorization_result_event) {\r\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.NotSet, isRenewProcess));\r\n            } else {\r\n                this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\r\n            }\r\n        }\r\n    }\r\n\r\n    startCheckingSilentRenew(): void {\r\n        this.runTokenValidation();\r\n    }\r\n\r\n    stopCheckingSilentRenew(): void {\r\n        if (this._scheduledHeartBeat) {\r\n            clearTimeout(this._scheduledHeartBeat);\r\n            this._scheduledHeartBeat = null;\r\n            this.runTokenValidationRunning = false;\r\n        }\r\n    }\r\n\r\n    resetAuthorizationData(isRenewProcess: boolean): void {\r\n        if (!isRenewProcess) {\r\n            if (this.configurationProvider.openIDConfiguration.auto_userinfo) {\r\n                // Clear user data. Fixes #97.\r\n                this.setUserData('');\r\n            }\r\n\r\n            this.oidcSecurityCommon.resetStorageData(isRenewProcess);\r\n            this.checkSessionChanged = false;\r\n            this.setIsAuthorized(false);\r\n        }\r\n    }\r\n\r\n    getEndSessionUrl(): string | undefined {\r\n        if (this.configurationProvider.wellKnownEndpoints) {\r\n            if (this.configurationProvider.wellKnownEndpoints.end_session_endpoint) {\r\n                const end_session_endpoint = this.configurationProvider.wellKnownEndpoints.end_session_endpoint;\r\n                const id_token_hint = this.oidcSecurityCommon.idToken;\r\n                return this.createEndSessionUrl(end_session_endpoint, id_token_hint);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getValidatedStateResult(result: any, jwtKeys: JwtKeys): ValidateStateResult {\r\n        if (result.error) {\r\n            return new ValidateStateResult('', '', false, {});\r\n        }\r\n\r\n        return this.stateValidationService.validateState(result, jwtKeys);\r\n    }\r\n\r\n    private setUserData(userData: any): void {\r\n        this.oidcSecurityCommon.userData = userData;\r\n        this._userData.next(userData);\r\n    }\r\n\r\n    private setIsAuthorized(isAuthorized: boolean): void {\r\n        this._isAuthorized.next(isAuthorized);\r\n    }\r\n\r\n    private setAuthorizationData(access_token: any, id_token: any) {\r\n        if (this.oidcSecurityCommon.accessToken !== '') {\r\n            this.oidcSecurityCommon.accessToken = '';\r\n        }\r\n\r\n        this.loggerService.logDebug(access_token);\r\n        this.loggerService.logDebug(id_token);\r\n        this.loggerService.logDebug('storing to storage, getting the roles');\r\n        this.oidcSecurityCommon.accessToken = access_token;\r\n        this.oidcSecurityCommon.idToken = id_token;\r\n        this.setIsAuthorized(true);\r\n        this.oidcSecurityCommon.isAuthorized = true;\r\n    }\r\n\r\n    private createAuthorizeUrl(\r\n        isCodeFlow: boolean,\r\n        code_challenge: string,\r\n        redirect_url: string,\r\n        nonce: string,\r\n        state: string,\r\n        authorization_endpoint: string,\r\n        prompt?: string\r\n    ): string {\r\n        const urlParts = authorization_endpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        let params = new HttpParams({\r\n            fromString: urlParts[1],\r\n            encoder: new UriEncoder(),\r\n        });\r\n        params = params.set('client_id', this.configurationProvider.openIDConfiguration.client_id);\r\n        params = params.append('redirect_uri', redirect_url);\r\n        params = params.append('response_type', this.configurationProvider.openIDConfiguration.response_type);\r\n        params = params.append('scope', this.configurationProvider.openIDConfiguration.scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n\r\n        if (isCodeFlow) {\r\n            params = params.append('code_challenge', code_challenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n\r\n        if (prompt) {\r\n            params = params.append('prompt', prompt);\r\n        }\r\n\r\n        if (this.configurationProvider.openIDConfiguration.hd_param) {\r\n            params = params.append('hd', this.configurationProvider.openIDConfiguration.hd_param);\r\n        }\r\n\r\n        const customParams = Object.assign({}, this.oidcSecurityCommon.customRequestParams);\r\n\r\n        Object.keys(customParams).forEach(key => {\r\n            params = params.append(key, customParams[key].toString());\r\n        });\r\n\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n\r\n    private createEndSessionUrl(end_session_endpoint: string, id_token_hint: string) {\r\n        const urlParts = end_session_endpoint.split('?');\r\n\r\n        const authorizationEndsessionUrl = urlParts[0];\r\n\r\n        let params = new HttpParams({\r\n            fromString: urlParts[1],\r\n            encoder: new UriEncoder(),\r\n        });\r\n        params = params.set('id_token_hint', id_token_hint);\r\n        params = params.append('post_logout_redirect_uri', this.configurationProvider.openIDConfiguration.post_logout_redirect_uri);\r\n\r\n        return `${authorizationEndsessionUrl}?${params}`;\r\n    }\r\n\r\n    private getSigningKeys(): Observable<JwtKeys> {\r\n        if (this.configurationProvider.wellKnownEndpoints) {\r\n            this.loggerService.logDebug('jwks_uri: ' + this.configurationProvider.wellKnownEndpoints.jwks_uri);\r\n\r\n            return this.oidcDataService\r\n                .get<JwtKeys>(this.configurationProvider.wellKnownEndpoints.jwks_uri || '')\r\n                .pipe(catchError(this.handleErrorGetSigningKeys));\r\n        } else {\r\n            this.loggerService.logWarning('getSigningKeys: authWellKnownEndpoints is undefined');\r\n        }\r\n\r\n        return this.oidcDataService.get<JwtKeys>('undefined').pipe(catchError(this.handleErrorGetSigningKeys));\r\n    }\r\n\r\n    private handleErrorGetSigningKeys(error: Response | any) {\r\n        let errMsg: string;\r\n        if (error instanceof Response) {\r\n            const body = error.json() || {};\r\n            const err = JSON.stringify(body);\r\n            errMsg = `${error.status} - ${error.statusText || ''} ${err}`;\r\n        } else {\r\n            errMsg = error.message ? error.message : error.toString();\r\n        }\r\n        this.loggerService.logError(errMsg);\r\n        return throwError(errMsg);\r\n    }\r\n\r\n    private runTokenValidation() {\r\n        if (this.runTokenValidationRunning || !this.configurationProvider.openIDConfiguration.silent_renew) {\r\n            return;\r\n        }\r\n        this.runTokenValidationRunning = true;\r\n        this.loggerService.logDebug('runTokenValidation silent-renew running');\r\n\r\n        /**\r\n         *   First time: delay 10 seconds to call silentRenewHeartBeatCheck\r\n         *   Afterwards: Run this check in a 5 second interval only AFTER the previous operation ends.\r\n         */\r\n        const silentRenewHeartBeatCheck = () => {\r\n            this.loggerService.logDebug(\r\n                'silentRenewHeartBeatCheck\\r\\n' +\r\n                    `\\tsilentRenewRunning: ${this.oidcSecurityCommon.silentRenewRunning === 'running'}\\r\\n` +\r\n                    `\\tidToken: ${!!this.getIdToken()}\\r\\n` +\r\n                    `\\t_userData.value: ${!!this._userData.value}`\r\n            );\r\n            if (this._userData.value && this.oidcSecurityCommon.silentRenewRunning !== 'running' && this.getIdToken()) {\r\n                if (\r\n                    this.oidcSecurityValidation.isTokenExpired(\r\n                        this.oidcSecurityCommon.idToken,\r\n                        this.configurationProvider.openIDConfiguration.silent_renew_offset_in_seconds\r\n                    )\r\n                ) {\r\n                    this.loggerService.logDebug('IsAuthorized: id_token isTokenExpired, start silent renew if active');\r\n\r\n                    if (this.configurationProvider.openIDConfiguration.silent_renew) {\r\n                        this.refreshSession().subscribe(\r\n                            () => {\r\n                                this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\r\n                            },\r\n                            (err: any) => {\r\n                                this.loggerService.logError('Error: ' + err);\r\n                                this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\r\n                            }\r\n                        );\r\n                        /* In this situation, we schedule a heartbeat check only when silentRenew is finished.\r\n                        We don't want to schedule another check so we have to return here */\r\n                        return;\r\n                    } else {\r\n                        this.resetAuthorizationData(false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            /* Delay 3 seconds and do the next check */\r\n            this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\r\n        };\r\n\r\n        this.zone.runOutsideAngular(() => {\r\n            /* Initial heartbeat check */\r\n            this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 10000);\r\n        });\r\n    }\r\n\r\n    private silentRenewEventHandler(e: CustomEvent) {\r\n        this.loggerService.logDebug('silentRenewEventHandler');\r\n\r\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\r\n            const urlParts = e.detail.toString().split('?');\r\n            const params = new HttpParams({\r\n                fromString: urlParts[1],\r\n            });\r\n            const code = params.get('code');\r\n            const state = params.get('state');\r\n            const session_state = params.get('session_state');\r\n            const error = params.get('error');\r\n            if (code && state) {\r\n                this.requestTokensWithCodeProcedure(code, state, session_state);\r\n            }\r\n            if (error) {\r\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.LoginRequired, true));\r\n                this.resetAuthorizationData(false);\r\n                this.oidcSecurityCommon.authNonce = '';\r\n                this.loggerService.logDebug(e.detail.toString());\r\n            }\r\n        } else {\r\n            // ImplicitFlow\r\n            this.authorizedImplicitFlowCallback(e.detail);\r\n        }\r\n    }\r\n}\r\n","import { ModuleWithProviders, NgModule } from '@angular/core';\r\nimport { OidcDataService } from '../data-services/oidc-data.service';\r\nimport { IFrameService } from '../services/existing-iframe.service';\r\nimport { EqualityHelperService } from '../services/oidc-equality-helper.service';\r\nimport { StateValidationService } from '../services/oidc-security-state-validation.service';\r\nimport { TokenHelperService } from '../services/oidc-token-helper.service';\r\nimport { LoggerService } from '../services/oidc.logger.service';\r\nimport { OidcSecurityCheckSession } from '../services/oidc.security.check-session';\r\nimport { OidcSecurityCommon } from '../services/oidc.security.common';\r\nimport { OidcConfigService } from '../services/oidc.security.config.service';\r\nimport { OidcSecurityService } from '../services/oidc.security.service';\r\nimport { OidcSecuritySilentRenew } from '../services/oidc.security.silent-renew';\r\nimport { BrowserStorage, OidcSecurityStorage } from '../services/oidc.security.storage';\r\nimport { OidcSecurityUserService } from '../services/oidc.security.user-service';\r\nimport { OidcSecurityValidation } from '../services/oidc.security.validation';\r\n\r\n@NgModule()\r\nexport class AuthModule {\r\n    static forRoot(token: Token = {}): ModuleWithProviders {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                OidcConfigService,\r\n                OidcSecurityService,\r\n                OidcSecurityValidation,\r\n                OidcSecurityCheckSession,\r\n                OidcSecuritySilentRenew,\r\n                OidcSecurityUserService,\r\n                OidcSecurityCommon,\r\n                TokenHelperService,\r\n                LoggerService,\r\n                IFrameService,\r\n                EqualityHelperService,\r\n                OidcDataService,\r\n                StateValidationService,\r\n                {\r\n                    provide: OidcSecurityStorage,\r\n                    useClass: token.storage || BrowserStorage,\r\n                },\r\n            ],\r\n        };\r\n    }\r\n}\r\n\r\nexport interface Type<T> extends Function {\r\n    new (...args: any[]): T;\r\n}\r\n\r\nexport interface Token {\r\n    storage?: Type<any>;\r\n}\r\n"]}